import { ref } from 'vue'
import type { LEDAnimation } from '~/composables/useOpenAI'

export const useArduinoCodeGenerator = () => {
  const generatedCode = ref<string>('')
  const isGenerating = ref(false)

  // Convert 2D matrix coordinates to physical LED index for serpentine (zigzag) layout
  // Most NeoPixel matrices are wired in a serpentine pattern
  const matrixToLedIndex = (row: number, col: number, width: number = 16): number => {
    // Start from bottom-left, go right, then zigzag up
    // Bottom row (15) = LEDs 0-15 (left to right)
    // Next row (14) = LEDs 16-31 (right to left)
    // etc.
    const physicalRow = 15 - row // Flip vertically (bottom = 0 in LED strip)
    
    if (physicalRow % 2 === 0) {
      // Even rows: left to right
      return physicalRow * width + col
    } else {
      // Odd rows: right to left (serpentine)
      return physicalRow * width + (width - 1 - col)
    }
  }

  const generateCode = (animation: LEDAnimation | null, pixels: string[][]) => {
    isGenerating.value = true

    try {
      const frames = animation ? animation.frames : [{ pixels, duration: 100 }]
      const frameCount = frames.length
      const loop = animation?.loop ?? false

      // Convert pixels to RGB arrays with correct physical mapping
      const frameData = frames.map(frame => {
        const width = frame.pixels[0]?.length || 16
        const height = frame.pixels.length
        
        // Create array for physical LED positions
        const ledArray = new Array(width * height).fill(null).map(() => ({ r: 0, g: 0, b: 0 }))
        
        // Map logical pixels to physical LED positions
        for (let row = 0; row < height; row++) {
          for (let col = 0; col < width; col++) {
            const color = frame.pixels[row]?.[col] || '#000000'
            const hex = color.replace('#', '')
            const r = parseInt(hex.substring(0, 2), 16) || 0
            const g = parseInt(hex.substring(2, 4), 16) || 0
            const b = parseInt(hex.substring(4, 6), 16) || 0
            
            const ledIndex = matrixToLedIndex(row, col, width)
            ledArray[ledIndex] = { r, g, b }
          }
        }
        
        return ledArray
      })

      // Generate Arduino code
      const code = `/*
 * ESP8266 NeoPixel Matrix Controller
 * Generated by LED Matrix Designer
 * 
 * Hardware:
 * - ESP8266 (NodeMCU, Wemos D1 Mini, etc.)
 * - 16x16 NeoPixel Matrix (WS2812B)
 * - Pin: D2 (GPIO4)
 * 
 * Matrix Layout:
 * - Serpentine (zigzag) wiring assumed
 * - Starts at bottom-left corner
 * - First row: left to right (LEDs 0-15)
 * - Second row: right to left (LEDs 16-31)
 * - And so on...
 * 
 * Libraries required:
 * - Adafruit NeoPixel (install via Library Manager)
 */

#include <Adafruit_NeoPixel.h>

// Configuration
#define LED_PIN     D2        // GPIO4 on most ESP8266 boards
#define LED_COUNT   256       // 16x16 matrix
#define BRIGHTNESS  50        // 0-255, lower = less power consumption

// Initialize NeoPixel strip
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

// Animation data
#define FRAME_COUNT ${frameCount}
${loop ? '#define LOOP_ANIMATION true' : '#define LOOP_ANIMATION false'}

// Frame durations in milliseconds
const int frameDurations[FRAME_COUNT] = {
${frames.map(f => `  ${f.duration}`).join(',\n')}
};

// Frame data: RGB values for each pixel
// Format: [R, G, B] for each of 256 pixels
const uint8_t frames[FRAME_COUNT][LED_COUNT][3] = {
${frameData.map((frame, frameIndex) => {
  const pixelLines: string[] = []
  
  // Group pixels in lines of 4 for readability
  for (let i = 0; i < frame.length; i += 4) {
    const pixelGroup = frame.slice(i, i + 4)
      .map(p => `{${p.r},${p.g},${p.b}}`)
      .join(', ')
    pixelLines.push(`    ${pixelGroup}${i + 4 < frame.length ? ',' : ''}`)
  }
  
  return `  { // Frame ${frameIndex + 1}\n${pixelLines.join('\n')}\n  }`
}).join(',\n')}
};

// Current frame index
int currentFrame = 0;
unsigned long lastFrameTime = 0;

void setup() {
  Serial.begin(115200);
  Serial.println("\\nESP8266 NeoPixel Matrix Starting...");
  
  // Initialize NeoPixel strip
  strip.begin();
  strip.setBrightness(BRIGHTNESS);
  strip.show(); // Initialize all pixels to 'off'
  
  Serial.println("NeoPixel Matrix initialized");
  Serial.print("Total frames: ");
  Serial.println(FRAME_COUNT);
  Serial.print("Loop animation: ");
  Serial.println(LOOP_ANIMATION ? "Yes" : "No");
}

void loop() {
  unsigned long currentTime = millis();
  
  // Check if it's time to show the next frame
  if (currentTime - lastFrameTime >= frameDurations[currentFrame]) {
    displayFrame(currentFrame);
    lastFrameTime = currentTime;
    
    // Move to next frame
    currentFrame++;
    
    // Handle end of animation
    if (currentFrame >= FRAME_COUNT) {
      if (LOOP_ANIMATION) {
        currentFrame = 0; // Loop back to start
      } else {
        currentFrame = FRAME_COUNT - 1; // Stay on last frame
      }
    }
  }
  
  // Small delay to prevent watchdog issues
  delay(1);
}

void displayFrame(int frameIndex) {
  Serial.print("Displaying frame: ");
  Serial.println(frameIndex + 1);
  
  // Set all pixels for this frame
  for (int i = 0; i < LED_COUNT; i++) {
    uint8_t r = frames[frameIndex][i][0];
    uint8_t g = frames[frameIndex][i][1];
    uint8_t b = frames[frameIndex][i][2];
    
    strip.setPixelColor(i, strip.Color(r, g, b));
  }
  
  // Update the strip
  strip.show();
}

// Optional: Function to adjust brightness at runtime
void setBrightness(uint8_t brightness) {
  strip.setBrightness(brightness);
  strip.show();
}

// Optional: Function to clear all pixels
void clearMatrix() {
  strip.clear();
  strip.show();
}
`

      generatedCode.value = code
      return code
    } finally {
      isGenerating.value = false
    }
  }

  const downloadCode = (filename: string = 'esp8266_matrix.ino') => {
    if (!generatedCode.value) return

    const blob = new Blob([generatedCode.value], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    link.click()
    URL.revokeObjectURL(url)
  }

  const copyToClipboard = async () => {
    if (!generatedCode.value) return false

    try {
      await navigator.clipboard.writeText(generatedCode.value)
      return true
    } catch (err) {
      console.error('Failed to copy to clipboard:', err)
      return false
    }
  }

  const getCodeStats = () => {
    if (!generatedCode.value) {
      return {
        lines: 0,
        size: '0 KB',
        sizeBytes: 0
      }
    }

    const lines = generatedCode.value.split('\n').length
    const sizeBytes = new Blob([generatedCode.value]).size
    const sizeKB = (sizeBytes / 1024).toFixed(2)

    return {
      lines,
      size: `${sizeKB} KB`,
      sizeBytes
    }
  }

  return {
    generatedCode,
    isGenerating,
    generateCode,
    downloadCode,
    copyToClipboard,
    getCodeStats
  }
}
